#define _CRT_SECURE_NO_WARNINGS
#define no_init_all
#include <Windows.h>
#include <iostream>
#include <vector>

/*
	--- Useful Links ---
	Code: https://www.cnblogs.com/Netsharp/p/14077129.html, https://www.winsim.com/diskid32/diskid32.cpp
	DeviceIoControl: https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol
	SMART_GET_VERSION: https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntdddisk/ns-ntdddisk-_getversioninparams
	SMART_RCV_DRIVE_DATA: https://learn.microsoft.com/en-us/previous-versions/windows/hardware/device-stage/drivers/ff566204(v=vs.85)
*/

#define ErrorPrint(x) \
	do { \
		std::wcerr << "Error at line " << __LINE__ << ": " << x << " (Error code: " << GetLastError() << ")" << std::endl; \
	} while (0)


typedef struct _IDENTIFY_DATA
{
	USHORT GeneralConfiguration;		// 00 00
	USHORT NumberOfCylinders;			// 02  1
	USHORT Reserved1;					// 04  2
	USHORT NumberOfHeads;				// 06  3
	USHORT UnformattedBytesPerTrack;	// 08  4
	USHORT UnformattedBytesPerSector;	// 0A  5
	USHORT SectorsPerTrack;				// 0C  6
	USHORT VendorUnique1[3];			// 0E  7-9
	USHORT SerialNumber[10];			// 14  10-19
	USHORT BufferType;					// 28  20
	USHORT BufferSectorSize;			// 2A  21
	USHORT NumberOfEccBytes;			// 2C  22
	USHORT FirmwareRevision[4];			// 2E  23-26
	USHORT ModelNumber[20];				// 36  27-46
	UCHAR MaximumBlockTransfer;			// 5E  47
	UCHAR VendorUnique2;				// 5F
	USHORT DoubleWordIo;				// 60  48
	USHORT Capabilities;				// 62  49
	USHORT Reserved2;					// 64  50
	UCHAR VendorUnique3;				// 66  51
	UCHAR PioCycleTimingMode;			// 67
	UCHAR VendorUnique4;				// 68  52
	UCHAR DmaCycleTimingMode;			// 69
	USHORT TranslationFieldsValid : 1;	// 6A  53
	USHORT Reserved3 : 15;
	USHORT NumberOfCurrentCylinders;	// 6C  54
	USHORT NumberOfCurrentHeads;		// 6E  55
	USHORT CurrentSectorsPerTrack;		// 70  56
	ULONG CurrentSectorCapacity;		// 72  57-58
	USHORT CurrentMultiSectorSetting;	//     59
	ULONG UserAddressableSectors;		//     60-61
	USHORT SingleWordDMASupport : 8;	//     62
	USHORT SingleWordDMAActive : 8;
	USHORT MultiWordDMASupport : 8;		//     63
	USHORT MultiWordDMAActive : 8;
	USHORT AdvancedPIOModes : 8;		//     64
	USHORT Reserved4 : 8;
	USHORT MinimumMWXferCycleTime;		//     65
	USHORT RecommendedMWXferCycleTime;	//     66
	USHORT MinimumPIOCycleTime;			//     67
	USHORT MinimumPIOCycleTimeIORDY;	//     68
	USHORT Reserved5[2];				//     69-70
	USHORT ReleaseTimeOverlapped;		//     71
	USHORT ReleaseTimeServiceCommand;	//     72
	USHORT MajorRevision;				//     73
	USHORT MinorRevision;				//     74
	USHORT Reserved6[50];				//     75-126
	USHORT SpecialFunctionsEnabled;		//     127
	USHORT Reserved7[128];				//     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

void PrintIdeInfo(int iDrive, DWORD dwDiskData[256]);

int main(int argc, char *argv[])
{
	HANDLE hDevice = CreateFileA("\\\\.\\PhysicalDrive0",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		ErrorPrint(L"CreateFile");
		exit(1);
	}

	DWORD bytesReturned;
	GETVERSIONINPARAMS lpOutBuffer;

	if (DeviceIoControl(hDevice,
		SMART_GET_VERSION, // 0x74080
		NULL,
		0,
		&lpOutBuffer,
		sizeof(lpOutBuffer),
		&bytesReturned,
		NULL))
	{
		printf("Successful call! Bytes returned: %u\nVers=%d.%d, Caps=0x%x, DeviceMap=0x%02x\n",
			bytesReturned, lpOutBuffer.bVersion, lpOutBuffer.bRevision, lpOutBuffer.fCapabilities, lpOutBuffer.bIDEDeviceMap);

#define IDENTIFY_BUFFER_SIZE 512
#define ID_CMD	0xEC // Returns ID sector for ATA
		ULONG CommandSize = sizeof(SENDCMDINPARAMS) + IDENTIFY_BUFFER_SIZE;
		PSENDCMDINPARAMS Command = (PSENDCMDINPARAMS)malloc(CommandSize);

		Command->irDriveRegs.bCommandReg = ID_CMD;
		bytesReturned = 0;
		if (DeviceIoControl(hDevice,
			SMART_RCV_DRIVE_DATA, // 0x7C088
			Command,
			sizeof(SENDCMDINPARAMS),
			Command,
			CommandSize,
			&bytesReturned,
			NULL))
		{
			// Print the IDENTIFY data
			DWORD dwDiskData[256]; // 256 is the IDENTIFY_DATA structure's size
			USHORT *punIdSector = (USHORT *)(PIDENTIFY_DATA)((PSENDCMDOUTPARAMS)Command)->bBuffer;
			for (int i = 0; i < 256; i++)
				dwDiskData[i] = punIdSector[i];

			PrintIdeInfo(0, dwDiskData);
		}
		else ErrorPrint(L"DeviceIoControl (SMART_RCV_DRIVE_DATA)");
	}
	else ErrorPrint(L"DeviceIoControl (SMART_GET_VERSION)");

	CloseHandle(hDevice);
}

char *ConvertToString(DWORD dwDiskData[256], int iFirstIndex, int iLastIndex, char *pcszBuf)
{
	int index = 0;
	int position = 0;

	// each integer has two characters stored in it backwards
	for (index = iFirstIndex; index <= iLastIndex; index++)
	{
		printf("%d ", dwDiskData[index]);
		//  get high byte for 1st character
		printf("dwDiskData[%d]=%d, /=%d, %=%d\n", index, dwDiskData[index], dwDiskData[index] >> 8, dwDiskData[index] & 0xFF);
		pcszBuf[position++] = (char)(dwDiskData[index] / 256);
		//printf("1: %c 2: %c\n", (char)(dwDiskData[index] / 256), (char)(dwDiskData[index] % 256));
		//  get low byte for 2nd character
		pcszBuf[position++] = (char)(dwDiskData[index] % 256);
	}

	//  end the string 
	pcszBuf[position] = '\0';

	//  cut off the trailing blanks
	for (index = position - 1; index > 0 && isspace(pcszBuf[index]); index--)
		pcszBuf[index] = '\0';

	return pcszBuf;
}

void PrintIdeInfo(int iDrive, DWORD dwDiskData[256])
{
	char cszSerialNumber[1024];
	char cszModelNumber[1024];
	char cszRevisionNumber[1024];
	char bufferSize[32];
	char m_cszHardDriveSerialNumber[1024];
	char m_cszHardDriveModelNumber[1024];

	__int64 i64Sectors = 0;
	__int64 i64Byte = 0;

	//  copy the hard iDrive serial number to the cszBuffer
	ConvertToString(dwDiskData, 10, 19, cszSerialNumber);
	ConvertToString(dwDiskData, 27, 46, cszModelNumber);
	ConvertToString(dwDiskData, 23, 26, cszRevisionNumber);
	sprintf_s(bufferSize, 32, "%u", dwDiskData[21] * 512);

	printf("%s %s %s\n", cszSerialNumber, cszModelNumber, cszRevisionNumber);
	if (0 == m_cszHardDriveSerialNumber[0] &&
		//  serial number must be alphanumeric
		//  (but there can be leading spaces on IBM drives)
		(isalnum(cszSerialNumber[0]) || isalnum(cszSerialNumber[19])))
	{
		strcpy_s(m_cszHardDriveSerialNumber, 1024, cszSerialNumber);
		strcpy_s(m_cszHardDriveModelNumber, 1024, cszModelNumber);
	}
}